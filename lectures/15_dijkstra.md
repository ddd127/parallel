## Delta stepping

Хотим найти кратчайшие расстояния от вершины A до всех остальных.

Параллельной дейкстры не бывает. 
Зато бывает параллельный форд-белман, но не в этот раз.

Глобальная идея:
- побьем вершины на бакеты B по расстоянию до A:
    0-delta, delta-2delta, ...
- будем релаксировать наименьший бакет, пока тот не кончится

Алгос:
```
fun relax(v: Vertex, x: newDistance) {
    if (x < d[v]) {
        B[d[v] / delta] -= v
        B[x / delta] += v
        d[v] = x
    }
}

for v in V {
    heavy = { edge(vu) > delta }
    light = { edge(vu) <= delta }
}
relax(a, 0)
iteration = 0
while B.isNotEmpty() {
    S = emptySet()
    // пока бакет релаксируется, релаксируем легкие ребра
    while B[iteration].isNotEmpty() {
        // parallel
        rqs = { (u, d[v] + edge(v, u) : v in B[i] && edge(v, u) in light }
        // parallel
        S += B[i]
        B[i] = emptySet()
        pfor (u, x) in rqs {
            relax(u, x)
        }
    }
    // обновляем heavy ребра 
    // parallel
    rqs = { (u, d[v] + edge(v, u) : v in S && edge(v, u) in heavy }
    pfor (u, x) in rqs {
        relax(u, x)
    }
    iteration += 1
}

Где-то перед релаксацией нужен radixSort, 
чтоб не апдейтить одну и ту же вершину дважды на итерации

Fun fact: если ребра натуральные и delta = inf,
получается форд-белман
Если же delta = 1, то дейкстра
```

А теперь математика:

Лемма: \
Пусть P x = число путей в графе, у которых вес меньше x

Утверждается, что число повторных вставок <= P delta \
Повторных релаксаций <= P 2delta

Доказывать будем для случайных графов G(n, d)

Доказательство через мат ожидания числа путей, 
меньше либо равных по весу некоторому количеству дельт и
путей, по количеству ребер не превышающих некоторого l.

Итоговый work у нас будет O(n * d) для такого графа.
