## Symmetry breaking

Дан цикл, заданный через массив next.

Нужно построить массив color такой, что
любые соседние вершины имеют разный цвет.

Очевидно, что нам нужно минимум три цвета.

1. `color[id] = id`
2. найдем minbit (минимальный индекс), считаем, что за const,
   в котором отличаются `color[id]` и `color[next[id]]`
3. `color[id] = 2 * minbit + color[id] + color[id].get(minbit)`

После одного применения такой штуки,
кол-во цветов превратится из n в 2 * log(n),
пока цветов не станет менее 8.

Применений может быть, очевидно, порядка log*(n)

```
Work = O(log*(n) * n)
Span = O(log*(n) * log(n))
```

Итого у нас есть константное число цветов. - от 0 до C

Теперь закрасим все вершины цвета 0, 1 и 2.
После этого пойдем по следующим цветам
и будем красить вершины в минимальный цвет,
которого нет у соседей.

Поскольку мы красим цвет за цветом,
мы никогда не попытаемся покрасить за одну итерацию
две соседние вершины.

```
Work = O(n)
Span = O(log(n))
```

Однако, если мы совместим обе части алгоритма, work будет `O(log*(n) * n)`.
Хочется меньше.

Проделаем битовую операцию один раз. Получим 2 * log(n) цветов,
каждый из которых <= 2 * log(n)
Теперь хочется их быстро отсортировать.
Идея: сортировка подсчетом за O(n) work и O(log^3(n)) span.

Когда мы все отсортируем, получим те самые списки элементов по цветам
```
Total
Work: O(n)    // honestly O(n * minbit)
Span: O(sorting span) = O(polylog)
```
