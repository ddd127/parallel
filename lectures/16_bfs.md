## BFS

Алгос, как пишут (c cas-ом). \
Non-deterministic, потому что CAS.

```
frontier = [S]
while frontier.isNotEmpty() {
    // parallel
    neighbours = { v.degree for v in frontier }
    sum = parallelScan(neignbours)
    processed = Array(neighbours.size, false)
    target = Array(sum)
    pfor v : frontier {
        pfor u : v.edges() {
            if (processed.cas(u, false, true)) {
                target[//index] = u
            }
        }
    }
}

Work +- O(n)
```

Рандомизированный алгос остовного дерева
с polylog span.

Beta-d декомпозиция графа G

Разобьем граф на части, такие, что 
каждая часть связна и ее диаметр не более d, 
а число ребер между частями <= Beta * |edges|.

Допустим, мы умеем делать такую декомпозицию. Тогда:

1. Сделаем декомпозицию
2. В каждой компоненте построим дерево
3. Сожмем граф (выкинув ребра-дубли integer sort-ом)
4. Снова декомпозиция

Итого мы уменьшаем число ребер в графе каждый раз 
как минимум в Beta раз, поэтому нужно log итераций.

Научимся делать (Beta, O(log(n) / Beta)) декомпозицию 
за O(m) work и O(log^3(n)) span.

1. Пошафлим вершины
2. Для k = 10..: выдадим 2^k вершинам число k
3. Соберем frontier = `[S]`
4. Сделаем шаг bfs-а и сделаем frontier += <вершины с числом i>
5. Если вершина пришла из прибавления, она - начало новой компоненты

Поскольку у нас log(n) различных чисел, диаметр компоненты не более log(n)

Почему именно Beta? Потому что статья. 
Если коротко, то из-за рандома и экспоненциального распределения 
вероятность ребра выжить - Beta.
