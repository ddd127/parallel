## String algorithms

### Поиск всех вхождений

Введем массив WITNESS, длинны `min(len / 2, period)`, такой, что 
`WITNESS[j] = k < len(WITNESS)`,
где k - какая-то позиция в сдвинутой на j строке такая, 
что `original[j + k - 1] != shifted[k]`

А теперь для пары строк Y, Z и пары индексов - i и j
введем следующую операцию:
duel(Y, Z, i, j): Int? - 
эта операция возвращает либо i, либо j, либо null \
Эта операция берет строку Z, 
прикладывает к ней строку Y со сдвигами i и j,
далее считает `Y_WITNESS[j - i + 1]`
(первый неравный эл-т в сдвинутых строках), 
а затем сравнивает эти неравные элементы с соответствующим индексом в Z.
Если кто-то совпал, этого кого-то возвращаем, иначе - null.

Теперь давайте искать шаблон Y в строке Z. Обе строки непериодические.

Поделим строку Z на подстроки размера m/2.

Для каждого блока соберем бинарное дерево дуэлей, 
получим число (или null).
Получаем максимум 2n/m чисел и ко всем тупо приложим искомую строку.

```
Work = O(2n / m * m) = O(n)
Span = polylog
```

Теперь про периодические строки: \
Пусть `Y = u^k + v, v = pref(u), Y' = Y[1..2p]`

Теперь сделаем предыдущий алгос для строки u, 
найдем позиции, где начинается u,
а прикладывать и проверять будем uuv.

Тогда мы нашли позиции, где может начинаться uuv,
и нам осталось проверить, что в предыдущих (k-2) элементах 
с шагом |u| могла начинаться u.


Осталось научиться считать WITNESS.

Пусть мы знаем WITNESS для первых t позиций.
Тогда утверждается, что для любой пары `i, j` такой, что |j - i| < t, 
мы знаем WITNESS хотя бы для одного элемента.
Это докажем чуть позже.

Если это так, то мы можем растить префикс по степеням двойки, 
каждый раз досчитывая последний неизвестный элемент втупую
(можно, по идее, за log).

Теперь о том, как имея i и j получить WITNESS для кого-то из них:
```
k = WITNESS[j - i + 1]

Первый случай, если k + j - 1 попадает в Y.

Y[k] != Y[k + j - i] =>
(Y[k + j - 1] != Y[k]) || (Y[k + j - 1] != Y[k + j - i]) =>
WITNESS для кого-то мы нашли.

Второй случай:

Y[k] != Y[k + j - i] =>
(Y[k] != Y[k - i + 1]) || (Y[k + j - i] != Y[k - i + 1])
```

Теперь немного пропатчим подсчет WITNESS 
и будем считать его префиксами по 2^alpha, не торопясь считать втупую, 
при этом учтя, что witness периода мы за просто так не узнаем.
Тогда выйдет намана.

```
Work = O(m)
Span = O(polylog)
```


### Суффиксный массив

`S = [a1, a2, ... an, $, $, $ ...] size of 2^it` \
Хотим получить массив следующего вида: \
`id = [id1, id2, id3, ... idn]` \
Такой, что суффиксы `s[id[x]..n]` упорядочены в порядке x

Алгос:
- посортим суффиксы длинны 1
- посортим суффиксы длинны 2 на основе суффиксов длинны 1
- ан-но со следующими степенями двойки до it

Каждый sort - это bucket sort, поэтому он за O(n), 
итоговый алгос - O(n * log(n))


Теперь пропатчим массив id:
```
id[x][q] = id строки, начинающейся с символа номер x с длинной 2^q
Если id[x][q] == id[y][q], то соответствующие строки равны.
```
Как его посчитать?
```
pfor i in 1..n:
    // char as id
    id[i][0] = s[i]
// deduplicate
for q in 1..log(n):

    // reserve, commit
    pfor i in 1..n:
        k1 = id[i][q - 1]
        k2 = id[i + 2^(q-1)][q - 1]
        bb[k1][k2] = i
    pfor i in 1..n:
        id[i][q] = bb[k1][k2]

В текущей реализации BB требует O(n^2) памяти, 
но можно за O(n ^ (1 + eps)) и за O(log^2(n) / eps) span
```


### Суффиксное дерево

Хотим сжатое суффиксное дерево.

Сначала посчитаем все id-шки и все bb массивы из предыдущего пункта.

Для начала построим просто блин дерево
с каждым суффиксом длинны n = 2^k (там ещё где-то $ валяются).

Далее поделим каждый суффикс пополам и смержим одинаковые начала, 
каждый раз копируя происходящее в новое дерево.
Тут тоже что-то про reserve, commit.

Вопрос: как искать в таком дереве подстроку p за log?

1. поймем, какой у строки p id по массивам bb, понятно, как
2. пойдем по нашим версионированным деревьям
   - если размер p меньше, чем суффиксы в текущем дереве, идем дальше.
   - если нет, то мы берем id первой "половины" p и ищем вершину
   - если нашли, recursive от этой вершины



### Суффиксный массив за линию

Работает только если символы в строке от 0 до n-1, 
потому что radix sort

1. Разобьем строку на последовательные подстроки длинны 3
2. Посортим из radix sort-ом и выдадим id-шки
3. Разделим подстроки по остатку от деления их позиции на 3
4. Остатки 1 и 2 склеим и рекурсивно запустимся
5. Посортим 0 остаток используя 1 и 2
6. Смержим результаты, пользуясь тем, что одно - продолжение другого.

```
Work = O(n)
Span = ?
```
