# Symmetry breaking, List ranking, Eulerian circuit

Дан цикл, заданный через массив next.

Нужно построить массив color такой, что 
любые соседние вершины имеют разный цвет.

Очевидно, что нам нужно минимум три цвета.

1. `color[id] = id`
2. найдем minbit (минимальный индекс), считаем, что за const, 
    в котором отличаются `color[id]` и `color[next[id]]`
3. `color[id] = 2 * minbit + color[id] + color[id].get(minbit)`

После одного применения такой штуки, 
кол-во цветов превратится из n в 2 * log(n), 
пока цветов не станет менее 8.

Применений может быть, очевидно, порядка log*(n)

```
Work = O(log*(n) * n)
Span = O(log*(n) * log(n))
```

Итого у нас есть константное число цветов. - от 0 до C

Теперь закрасим все вершины цвета 0, 1 и 2. 
После этого пойдем по следующим цветам 
и будем красить вершины в минимальный цвет, 
которого нет у соседей.

Поскольку мы красим цвет за цветом, 
мы никогда не попытаемся покрасить за одну итерацию
две соседние вершины.

```
Work = O(n)
Span = O(log(n))
```

Однако, если мы совместим обе части алгоритма, work будет `O(log*(n) * n)`.
Хочется меньше.

Проделаем битовую операцию один раз. Получим 2 * log(n) цветов, 
каждый из которых <= 2 * log(n)
Теперь хочется их быстро отсортировать. 
Идея: сортировка подсчетом за O(n) work и O(log^3(n)) span.

Когда мы все отсортируем, получим те самые списки элементов по цветам
```
Total
Work: O(n)    // honestly O(n * minbit)
Span: O(sorting span) = O(polylog)
```



## List ranking

Дан список из n вершин, заданный массивом next.
Последняя вершина смотрит в себя.

Хотим для каждой вершины найти расстояние до конца.

Можно за O(n * log(n)) work и O(log(n)) span
сделать что-то типа двоичных подъемов, прыгая каждый раз на 2^i.

```
len = [1, 1, 1, ...] // 0 where end
for _ in 0..log(n):
    old_next = next
    old_len = len
    pfor i in 0 until n:
        next = old_next[old_next[i]]
        len = old_len[i] + old_len[old_next[i]]
```

Попробуем уменьшить задачу до n / log(n).

Покрасим вершинки в три цвета. 
Вершин какого-то цвета >= n/3. 
Выкинем их из списка, попутно запомнив, где они были, 
и увеличив соответствующий len до 2-х.

Тогда применив такую штуку log(log(n)) раз 
мы сведем задачу к нужному размеру.

```
Work = O(n * log(n))
Span = O(log^2(n) * log(log(n)))
```
