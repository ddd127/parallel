## Biconnectivity

Хотим разбить граф на мосты и блоки.

Сначала через просто connectivity построим остов и подвесим его.

Теперь:
ребро из вершины u к родителю является мостом тогда и только тогда, 
когда не существует ребер, ведущих из этого поддерева вовне.

Как это искать?
1. посчитаем для каждой вершины tin и tout.

2. (зная tin и tout знаем размеры поддеревьев)

3. для каждой вершины заведем min_tout и max_tin по всем соседям. 
    (отсортируем ребра и сделаем scan на min-max).

4. теперь посчитаем tin и tout для каждого поддерева.

5. если все концы ребер в поддереве v 
    попадают в (tin, tout v) то `v->p[v]` - мост.

Итого мы нашли компоненты реберной двусвязности. 
Теперь найдем компоненты вершинной двусвязности в этом графе

Отметим, что каждое ребро вне дерева образует базовый цикл.

Для этого ребра и ребер, идущих из концов в предков, 
построим двойственные ребра. 
А также построим двойственные для ребер, подряд идущих наверх, 
если из поддерева вершины между ними есть ребра наружу.
