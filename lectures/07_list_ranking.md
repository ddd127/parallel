## List ranking

Дан список из n вершин, заданный массивом next.
Последняя вершина смотрит в себя.

Хотим для каждой вершины найти расстояние до конца.

Можно за O(n * log(n)) work и O(log(n)) span
сделать что-то типа двоичных подъемов, прыгая каждый раз на 2^i.

```
len = [1, 1, 1, ...] // 0 where end
for _ in 0..log(n):
    old_next = next
    old_len = len
    pfor i in 0 until n:
        next = old_next[old_next[i]]
        len = old_len[i] + old_len[old_next[i]]
```

Попробуем уменьшить задачу до n / log(n).

Покрасим вершинки в три цвета.
Вершин какого-то цвета >= n/3.
Выкинем их из списка, попутно запомнив, где они были,
и увеличив соответствующий len до 2-х.

Тогда применив такую штуку log(log(n)) раз
мы сведем задачу к нужному размеру.

```
Work = O(n * log(n))
Span = O(log^2(n) * log(log(n)))
```

### Randomized list ranking:

Будем сводить задачу к меньшей следующим образом:

- рандомно назначим вершинам роли - Tail или Head
- вырежем те вершины, которые сами - Tail и ведут в Head

Теперь докажем, что за O(log(n)) шагов
алгоритм дойдет до размера n / log(n)

Поделим список на последовательные пары - `x[i]` 
и будем ждать комбинацию T, H
Тогда вероятность такой комбинации - 1/4 для n/2 пар, =>
в среднем мы будем выкидывать n/8 элементов.

Upper tail theorem:
`P[x > (1 + d) * m] <= e ^ -(m * d^2 / 3), 0 <= d <= 1`

Назовем `x[i]` вероятность того, что пара осталась - т.е. 3/4.

Теперь докажем, что
```
x = x1 + x2 + ...
m = E[x1 + x2 + ..]
P[(x1 + x2 + ...) >= (1 + d) * 3/8 n] <= e ^ (3/8 n * d^2 / 3)
```
Теперь подберем d таким, чтобы (1 + d) * 3/8 n = 7/16 n

d = 1/6

Тогда `P[x >= 7/16 n] <= e ^ -(n / c)`

Значит, вероятность того, что все попытки будут успешными:

```
(1 - e ^ -(n / c)) *
  * (1 - e ^ -(15n/16 / c)) * ... *
  * (1 - e ^ -((n/log(n)) / c)) >=
  (1 - e ^ (n / (c * log(n))) * log 16/15 (log(n)) * >=
  1 - log 16/15 (log(n)) * e ^ (n / (c * log(n)) >=
  1 - 1 / (n^a)
```


