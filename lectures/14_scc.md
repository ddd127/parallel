## Strongly connected components

Ищем компоненты сильной связности в связанном графе.

Утверждается, что быстрее, чем за O(m * log(n)) нельзя

1. Берем случайную вершину в графе
2. Обходим все достижимые по прямым ребрам, назовем это множество succ
3. Обходим все достижимые по обратным, назовем это множество pred
4. Компонента сильной связности = succ intersect pred
5. Наблюдение - не бывает компоненты сильной связности, 
    которая пересекается с pred или sec частично

Итого у нас есть четыре компоненты - C (собсна, пересечение), 
pred, succ и all

Далее мы делаем fork3join от (pred - c), (succ - c) и all - (pred + succ).

Получился +- divide and concurrer алгоритм

Теперь докажем, что work = O(m * log (n)).
Делать это будем, доказывая, что каждое ребро пройдено не более log(n) раз

Сделаем псевдо-top-sort, сначала со сжатыми компонентами, 
чтобы нумеровать ациклический граф, 
а потом пронумеруем как-то внутри компонент.

Рассмотрим какое-то ребро графа. Пусть оно будет пройдено d(n) раз. 
Тогда, исходя из логики упорядочивания:
`d(n) <= 1 + 1/n * sum[i: i..n-1] { d(i) }`

Далее докажем, что `d(r) <= 1 + 1/2 + ... + 1/r`, 
через математику вычитания `r * d(r) - (r - 1) * d(r - 1)`

Okay, мы доказали expected. 
Теперь хочется доказать, что какую бы мы вершину ни взяли, 
время работы будет m * log(n).

Для этого детерминируем алгоритм так:
1. берем случайную вершину
2. начинаем делать dfs по одному ребру в каждую строну
3. когда обойдем до конца p или s, остановимся

Пусть наименьшим множеством оказалось p.

Тогда:
```
Пусть:
c = edges(компонента)
p = edges(pred - c)
s = edges(succ - c)
a = all

T(m) = T(p) + T(m - p - c) + O(p + c)
Далее будет индукция с фокусами на логарифмах 
и использованием того, что m >= 2p
```
