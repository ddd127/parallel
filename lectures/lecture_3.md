# Divide-and-Conquer, Accelerating Cascades, Pipelining

## Divide-and-Conquer

Будем рекурсивно делить задачу на подзадачи 
и затем собирать итоговый результат из результатов подзадач.

### Пример: mergesort

```
fun List<T>.mergeSorted(
    block: Int,
    l: Int,
    r: Int,
): List<T> {
    if (r - l < block) {
        return this.view(l, r).sorted()
    }
    val m = (l + r) / 2
    val left = async { mergeSorted(block, l, m) }
    val right = async { mergeSorted(block, m, r) }
    return merge(left.await(), right.await())
}
```

Допустим, span merge = O(M(n)). Тогда

```
Work = O(n * log(n)),
Span = O(log(n) * (M(n) + M(n / 2) + M(n / 4) + ...)) =
     = O(log(n) * M(n))    // если M - полилог
```

### Параллельный merge:

Тупой вариант:

За Work = O(n * log(n)) и Span = O(log(n)) найдем каждому элементу 
каждого массива его место в результирующем массиве через бин поиск.

Вариант поумнее:

Побьем каждый массив на блоки размера log(n).
Для каждого старта блока из первого массива
найдем его место во втором бин поиском, 
аналогично - для слишком больших блоков из 2-го массива.

Тогда merge каждого куска у нас за log(n) work, а total merge-а такой:
```
Span = O(log(n))
Work = O(n / log(n) * log(n)) = O(n)
```


## Accelerating cascades


### K-я порядковая статистика

Тупое решение - отсортировать. Work = O(n * log(n)), Span = O(log^2(n))

k = n / log(n)
O(k * log(k)) = n / log(n) * log(n / log(n)) = 

Сведение задачи к меньшей:

- Побьем на блоки по log(n)
- Возьмем медиану в каждом из них за O(log(n))
- Найдем медиану медиан тупым решением за work = O(n), span = O(log^2(n))
- С помощью итоговой медианы поделим массив и выберем нужную половину

Сведем задачу к меньшей log(log(n)) раз, чтобы получить размер n / log(n)

Тогда work = O(n), span = O(log^2(n) * log(log(n)))


### max в common CRCW

Заведем табличку t размера n^2 заполненную true
```
pfor i in 1..n:
    pfor j in 1..n:
        if (arr[i] < arr[j]):
            is_max[i] = false
pfor i in 1..n:
    if (is_max[i]):
        ans = i

Work = O(n^2)
Depth = O(1)
``` 

Work ужасный, попробуем быстрее

```
n = 2 ^ (2 ^ k)
Заведем дерево, где сверху вниз у каждой вершины детей будет:
2^(2 ^ (k - 1))
2^(2 ^ (k - 2))
...
2^(2 ^ 0) = 2
Очевидно, что таких уровней будет log(log(n))

На каждом уровне для каждой вершины запустим предыдущий алгос.

Теперь оценим количество вершин:
На уровне i количество вершин = 2 ^ (2^k - 2^(k - i))
Количество детей у такой вершины - 2 ^ (2 ^ (k - i - 1))

Тогда на кажом уровне work:
2 ^ (2^k - 2^(k - i)) * (2 ^ (2 ^ (k - i - 1))) ^ 2 =
  = 2 ^ (2^k - 2^(k - i)) * 2 ^ (2 ^ (k - i)) =
  = 2 ^ (2 ^ k)
  = n

Work = n * log(log(n))
Depth = log(log(n))
```

Finally, будем сводить задачу к меньшей за O(1)/O(n),
каждый раз деля массив пополам (просто беря максимум из соседних)
и сделаем так log(log(log(n))) раз.
```
Work = O(n)
Depth = O(log(log(log(n))))
```


## Pipelining

Пусть нам дано 2-3 дерево размера n.
Мы хотим вставить в него m элементов

Если никакие элементы не попадают в одну и ту же дырку, всё ок -
мы сможем обработать такие кейсы leve-by-level
```
Span = O(log(n) * log(m))
```

А вот если попадают, то:
- вставим сначала средний (до конца)
- потом два средних из двух половин
- и тд
```
Span = O(log(1) * log(n) + log(2) * log(n) + ... + log(m) * log(n)) =
  = O(log^2(m) * log(n))
```

А теперь pipelining:
начнем вставлять следующие элементы после того, 
как пропихнули следующие на 1 + 1 вверх, чтоб нижний lvl зафиксировался.
```
Span = O(log(m) * (log(n) + log(m)))
```
