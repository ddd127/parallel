## Accelerating cascades

### K-я порядковая статистика

Тупое решение - отсортировать. Work = O(n * log(n)), Span = O(log^2(n))

k = n / log(n)
O(k * log(k)) = n / log(n) * log(n / log(n)) =

Сведение задачи к меньшей:

- Побьем на блоки по log(n)
- Возьмем медиану в каждом из них за O(log(n))
- Найдем медиану медиан тупым решением за work = O(n), span = O(log^2(n))
- С помощью итоговой медианы поделим массив и выберем нужную половину

Сведем задачу к меньшей log(log(n)) раз, чтобы получить размер n / log(n)

Тогда work = O(n), span = O(log^2(n) * log(log(n)))

### max в common CRCW

Заведем табличку t размера n^2 заполненную true
```
pfor i in 1..n:
    pfor j in 1..n:
        if (arr[i] < arr[j]):
            is_max[i] = false
pfor i in 1..n:
    if (is_max[i]):
        ans = i

Work = O(n^2)
Depth = O(1)
``` 

Work ужасный, попробуем быстрее

```
n = 2 ^ (2 ^ k)
Заведем дерево, где сверху вниз у каждой вершины детей будет:
2^(2 ^ (k - 1))
2^(2 ^ (k - 2))
...
2^(2 ^ 0) = 2
Очевидно, что таких уровней будет log(log(n))

На каждом уровне для каждой вершины запустим предыдущий алгос.

Теперь оценим количество вершин:
На уровне i количество вершин = 2 ^ (2^k - 2^(k - i))
Количество детей у такой вершины - 2 ^ (2 ^ (k - i - 1))

Тогда на кажом уровне work:
2 ^ (2^k - 2^(k - i)) * (2 ^ (2 ^ (k - i - 1))) ^ 2 =
  = 2 ^ (2^k - 2^(k - i)) * 2 ^ (2 ^ (k - i)) =
  = 2 ^ (2 ^ k)
  = n

Work = n * log(log(n))
Depth = log(log(n))
```

Finally, будем сводить задачу к меньшей за O(1)/O(n),
каждый раз деля массив пополам (просто беря максимум из соседних)
и сделаем так log(log(log(n))) раз.
```
Work = O(n)
Depth = O(log(log(log(n))))
```
