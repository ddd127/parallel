## Connectivity

Хотим быстро искать компоненты связности в графе, 
заданном матрицей смежности.

### Первый способ (для плотных графов):

Создадим массив `p[]`, который для каждой вершины указывает 
её соседа с наименьшим id.

Итого получили лес деревьев, 
подвешенных за вершину с минимальным id, 
где из корня есть одно ребро в куда-то. 
Такое ребро аккуратно перевесим в саму вершину.

Теперь сделаем следующее:
```
repeat(log(n)) {
    old_p = p
    pfor i in 0 until n:
        p[i] = old_p[old_p[i]]
}
```
Теперь все деревья выглядят как дерево из корня и листьев, 
поэтому мы можем быстро их покрасить - сказать, что если parent-a нет, 
то мы и есть цвет, а если есть, то наш цвет - цвет parent-а.

Теперь у нас есть `c[]` - цвет каждой вершины, один цвет => одна компонента
(но не наоборот!).
Отсортируем вершины по цвету за O(n * log(n)) work, 
далее сожмем каждый цвет в одну вершину и построим новую 
матрицу смежности, где ребро между цветами A и B будет тогда и только тогда, 
когда было хотя бы одно ребро, связывающее вершины цветов A и B.

Итерация стоит:
```
Work = O(n^2)
Span = O(polylog)
```

А сколько нужно таких итераций?

После каждой итерации становится хотя бы в 2 раза меньше вершин, 
поэтому span останется таким же, а work будет все еще O(n^2), потому что
`Work = O(n1^2 + n2^2 / 4 + n3^2 / 16 + ...) = O(n1^2) = O(n^2)`

### Второй способ (для разреженных графов):

Сделаем одну итерацию из предыдущего способа.

Далее:
```
repeate(log(n)) {
    pfor uv in edges {
        // подвесим вершину, если она root,
           но из нее на самом деле есть ребро в другое дерево
        if p[u] == p[p[u]] && p[u] > p[v] {
            p[p[u]] = p[v]
        }
    }

    // куда-то подвешиваем "звезды" (смотрящие сами в себя + их дети), 
       чтобы потом не поломать док-во про уменьшение высот.
       Звезда, которую не подвесить - уже компонента, можно выкинуть.
    pfor uv in edges {
        if v is star && p[u] != p[v] {
            p[p[u]] = p[u]
        }
    }

    // собсна, сжимаем
    pfor v in vertexes {
        p[v] = p[p[v]]
    }

    // тут в 1-м и 2-м циклах есть гонки, 
       мы стоически решили сортировать ребра - "и так сойдет"
}

Work = O(m * log n) // log^2 если сортить
```

Суть в том, что высота деревьев каждый раз уменьшается хотя бы в 3/2 раза, 
если подумать - то понятно, почему.
